'''
envmanager.py

A module to manage multiple .env files stored in a single root directory.
The root directory is defined by the environment variable `ENV_ROOT_DIR` on the OS level.

Usage:
    from envmanager import EnvManager
    env = EnvManager()               # reads ENV_ROOT_DIR
    env.load('project1', override=True)  # loads project1.env into os.environ
    API_KEY = env.get('API_KEY')     # fetch variable

Optionally, use as a script:
    python envmanager.py project1     # loads project1.env
'''
import json
import os
import warnings
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, Optional, Tuple

from dotenv import dotenv_values, load_dotenv

from src.util import is_env_file


_ENV_VAR_KEY = 'PY_ENV_ROOT'
"""The key under which the root directory of the .env file system is registered as environmental variable"""


_ROOT: str = os.environ.get(_ENV_VAR_KEY, None)
"""Root directory as registered in os.environ with key=`ENV_VAR_KEY`"""

# Root is not registered in Environmental Variables -> execute setup + exit
if _ROOT is None:
    from src.setup import setup_environmental_variable
    exit(setup_environmental_variable(key=_ENV_VAR_KEY))


@dataclass(frozen=True, slots=True)
class EnvManager:
    """
    Manages loading .env files from a central directory and additional registered env files in the env json dict.
    Can also be used to get specific environmental variables via `get(variable_name)` or using
    EnvManager()[variable_name]
    
    Methods
    -------
    register_external_env(*path: str, **kwargs)
        Register one or more `.env` files that live outside of the central `root` directory.
        Positional `path` arguments are treated as file paths (the key is derived from the filename).
        Keyword arguments are explicit `key=path` pairs. Nonexistent files or duplicate keys
        are skipped with a warning. Updates the JSON index at `env_json`.

    load(key: str, override: bool = True, verbose: bool = False) → bool
        Load the `.env` file identified by `key` into `os.environ` (using `dotenv.load_dotenv`).
        If `override=True`, existing variables in `os.environ` will be overwritten.
        Returns `True` if at least one variable was set, `False` otherwise.
        Raises `FileNotFoundError` if no file is found for `key`.

    get(key: str, default: Optional[str] = None, skip_warning: bool = False) → Optional[str]
        Retrieve the value of environment variable `key` from `os.environ`.
        If unset, emits a warning (unless `skip_warning=True`) and returns `default`.
    
    """
    root: str = field(default=os.environ[_ENV_VAR_KEY], init=False)
    """Root directory in which the .env files are stored by default."""
    
    env_json: str = field(default=os.path.join(_ROOT, "environmental_variable_files.json"), init=False)
    """Path to a JSON file with references to .env files that are located outside of `root`"""
    
    encoding: str = field(default='utf-8', init=False)
    """Encoding applied to .env files generated by this manager."""
        
    def register_external_env(self, *path: str, **kwargs):
        """Registers .env files located outside of the root directory.
        
        Parameters
        ----------
        path : str
            One or more paths to env files. The key is derived from the file name in the path.
        kwargs
            One or more key, path pairs to register.
        """
        if path:
            kwargs.update({os.path.splitext(os.path.split(p)[-1])[0]: p for p in path})
        
        if not kwargs:
            return
        
        msg = []
        registered_envs = self.registered_envs
        cur = set(self.registered_envs.keys())
        for k, v in kwargs.items():
            if not os.path.isfile(v):
                msg.append(f"{k}={v} (path does not exist)")
                del kwargs[k]
            elif k in cur:
                msg.append(f"{k}={v} (key is already registered)")
                del kwargs[k]
            else:
                registered_envs[k] = v
        if len(msg) > 0:
            import warnings
            msg = "\n\t".join(["Unable to register the following environment variable files:"] + msg)
            warnings.warn(msg)
        
        path_dict = {**json.load(open(self.env_json)), **kwargs}
        json.dump(path_dict, open(str(self.env_json), 'w'))
    
    @property
    def external_env_files(self) -> Dict[str, str]:
        """Contents of the external environment files JSON"""
        if not os.path.exists(self.env_json):
            json.dump({}, open(self.env_json, "w"))
            return {}
        
        return json.load(open(self.env_json, 'r'))
    
    @property
    def registered_envs(self) -> Dict[str, str]:
        """Dict with all of the environment variable files managed by this manager."""
        path_dict = {}
        
        for f in os.listdir(self.root):
            path = os.path.join(self.root, f)
            if is_env_file(path):
                path_dict[f.rstrip(".env")] = path
                
        path_dict.update(self.external_env_files)
        return path_dict
    
    @property
    def env_vars(self) -> Tuple[str, ...]:
        """The variables currently registered in os.environ"""
        return tuple(os.environ.keys())
        
    
    def load(self, key: str, override: bool = True, verbose: bool = False) -> bool:
        """Load a .env file by key into os.environ. By default, the key is equal to the file name without the .env
        extension.
        
        Parameters
        ----------
        key : str
            The key that refers to the requested .env file
        override : bool, optional, True by default
            If True, override the os.environ variables with the parsed variables
        verbose : bool, optional, False by default
            Verbose param passed to the dotenv loader

        Returns
        -------
        bool
            True if at least one environment variable is set else False (from load_dotenv)
        
        Raises
        ------
        FileNotFoundError
            Raised if the .env file paired with `key` does not exist.
        """
        env_file = Path(self.registered_envs[key])
        if not env_file.exists():
            raise FileNotFoundError(f"""Unable to find env file at path "{env_file!r}" """)
        return load_dotenv(dotenv_path=env_file, override=override, encoding=self.encoding, verbose=verbose)

    def get(self, key: str, default: Optional[str] = None, skip_warning: Optional[bool] = None) -> str:
        """Get the environment variable registered under `key`. If it does not exist, raise a warning and return
        `default`.
        
        Parameters
        ----------
        key : str
            The name of the requested environment variable.
        default : Optional[str], None by default
            The default value to return if the environment variable is not set
        skip_warning : Optional[bool], False by default
            If True, do *not* issue a warning if the value does not exist

        Returns
        -------
        str | None
            The environment variable registered under `key`, or `default` if it does not exist
        """
        value = os.environ.get(key)
        if value is None:
            msg = f"There is no variable named {key} registered as environmental variable. Returning {default} instead."
            warnings.warn(msg)
            return default
        return value
    
    def dict(self, key: str) -> Dict[str, Optional[str]]:
        """Return a dict of key/value pairs from the .env file registered under `key` without modifying os.environ"""
        path = Path(self.registered_envs[key])
        if not path.exists():
            raise FileNotFoundError(f"""Env file registered at path='{path!r}' under key={key} does not exist...""")
        return dotenv_values(str(path), encoding=self.encoding)
    
    def __getitem__(self, key: str) -> Optional[str]:
        return os.environ.get(key)


__all__ = ["EnvManager"]